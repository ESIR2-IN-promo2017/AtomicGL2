<?xml version="1.0" encoding="UTF-8"?>

<SHADER name="cartoonProg">
	<VERTEX>
		<ATTRIBUTES>
			attribute vec3 aVertexPosition;
			attribute vec3 aVertexNormal;
			attribute vec3 aVertexColor;
		</ATTRIBUTES>

		<UNIFORMS>
			uniform mat4 uMVMatrix;
			uniform mat4 uPMatrix;
			uniform mat3 uNMatrix;
		</UNIFORMS>

		<VARYING>
			varying vec3 vPosition;
			varying vec3 vNormal;
			varying vec3 vColor;
		</VARYING>

		<OUTPUT>
		    void main(void) {
	    		vec4 homogeneousPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
				
				vNormal = uNMatrix * aVertexNormal;
	    		vPosition = vec3(homogeneousPosition)/homogeneousPosition.w;
	    		vColor = aVertexColor;

				gl_Position = uPMatrix * homogeneousPosition;
	    	}
		</OUTPUT>
	</VERTEX>

	<FRAGMENT>
		<PRECISION>
			#ifdef GL_ES
 				precision highp float;
 			#endif

			#define NB_POINTLIGHTS
			#define NB_SPOTLIGHTS
			#define NB_DIRECTIONNALLIGHTS

			struct pointLight{
				vec3 position;
				vec3 color;
				vec3 intensity;
			};

			struct spotLight{
				vec3 position;
				vec3 direction;
				vec3 color;
				float radius;
				vec3 intensity;
			};

			struct directionnalLight{
				vec3 direction;
				vec3 color;
				vec3 intensity;
			};
		</PRECISION>

		<UNIFORMS>
		    uniform pointLight pointLights[NB_POINTLIGHTS];
		    uniform spotLight spotLights[NB_SPOTLIGHTS];
		    uniform directionnalLight directionnalLights[NB_DIRECTIONNALLIGHTS];
		</UNIFORMS>

		<VARYING>
			varying vec3 vPosition;
			varying vec3 vNormal;
			varying vec3 vColor;
		</VARYING>

		<OUTPUT>
			// edge color
			vec3 edgeColor = vec3(0.0,0.0,0.0);
			// shadow color
			vec3 shadowColor = vec3(0.0, 0.0, 0.5);
			// midtoneColor
			vec3 midtoneColor = vec3(0.0,0.0,1.0);
			// highlight color
			vec3 highLightColor = vec3(1.0,1.0, 1.0);

			// Kd: diffuse coeff, Ks: specular coeff, sh: specular exponent
			float Kd = 0.5 ;
			float Ks = 0.5 ;
			float sh = 8.0 ;

			// thresholds
			float shadowMidtone = 0.0;
			float midToneHighLight = 0.75 ;
			float edgeThreshold = 0.95 ;

			// specular color
			vec3 specColor = vec3(1.0,1.0,1.0);

			void main(void) {
				vec3 normal = normalize(vNormal);

				vec3 eyeDirection = normalize(-vPosition);
				vec3 lightDirection = vec3(0.0,0.0,0.0);
				vec3 reflectDirection = vec3(0.0,0.0,0.0);
				
				float diffuseLightWeight = 0.0;
				float specularLightWeight = 0.0;	

				float distance = 0.0;

				vec3 lightColor = vec3(0.0,0.0,0.0);
				float temp;

				//////////////////
				// Point Lights //
				//////////////////
				for(int i=NB_POINTLIGHTS-1; i>=0; i--)
		    	{
		    		lightDirection = normalize(pointLights[i].position - vPosition);

					// distance
					distance = sqrt(pow(pointLights[i].position.x,2.0) + pow(pointLights[i].position.y,2.0) + pow(pointLights[i].position.z,2.0));

					// diffuse term
					diffuseLightWeight = max(dot(lightDirection,normal), 0.0);

					if(diffuseLightWeight > 0.0)
					{
						// reflection direction
						reflectDirection = reflect(-lightDirection,normal);

						// specular term
					    float specAngle = max(dot(reflectDirection, eyeDirection), 0.0);
					    float specular = pow(specAngle, 4.0);

						// light color
						temp = Kd*diffuseLightWeight + Ks*specular;
					}

					// edge term
					float edge = sqrt(1.0 - pow(max(dot(normal,eyeDirection),0.0),2.0));

					if (edge > edgeThreshold)
						lightColor += edgeColor;
					else if (shadowMidtone >= temp)
						lightColor += shadowColor;
					else if (midToneHighLight >= temp)
						lightColor += midtoneColor;
					else
						lightColor += highLightColor;
				}

				gl_FragColor = vec4(lightColor,1.0);
			}
		</OUTPUT>
	</FRAGMENT>
</SHADER>
