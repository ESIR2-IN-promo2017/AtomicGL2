<html >
<head>
	<title >atomicGL DEBUG </title>
	<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

	<script type="text/javascript" src="gltp1_fichiers/glMatrix-0.js"></script>
	<script type="text/javascript" src="gltp1_fichiers/webgl-utils.js"></script>
	
	<!-- ATOMICGL ENGINE -->
	<!-- load "objects" -->
	<script type="text/javascript" src="objs/palais_v01_bois_parquet.js"></script>
	<script type="text/javascript" src="objs/palais_v01_bois_poutre.js"></script>
	<script type="text/javascript" src="objs/palais_v01_decors.js"></script>
	<script type="text/javascript" src="objs/palais_v01_mur.js"></script>
	<script type="text/javascript" src="objs/palais_v01_terrase.js"></script>
	<script type="text/javascript" src="objs/palais_v01_toiture.js"></script>
	
	<script type="text/javascript" src="objs/donjonBase.js"></script>
	<script type="text/javascript" src="objs/donjonBois.js"></script>
	<script type="text/javascript" src="objs/donjonFenetre.js"></script>
	<script type="text/javascript" src="objs/donjonMur.js"></script>
	<script type="text/javascript" src="objs/donjonSol.js"></script>
	<script type="text/javascript" src="objs/donjonToiture.js"></script>

	<script type="text/javascript" src="objs/maison1mur.js"></script>
	<script type="text/javascript" src="objs/maison1sol.js"></script>
	<script type="text/javascript" src="objs/maison1stone.js"></script>
	<script type="text/javascript" src="objs/maison1stone2.js"></script>
	<script type="text/javascript" src="objs/maison1toit.js"></script>
	<script type="text/javascript" src="objs/maison1wood.js"></script>

	<script type="text/javascript" src="objs/maison3.js"></script>
	<script type="text/javascript" src="objs/maison3roof.js"></script>
	<script type="text/javascript" src="objs/maison3wood.js"></script>
	
	<script type="text/javascript" src="objs/sol_herbe.js"></script>
	<script type="text/javascript" src="objs/sol_route.js"></script>
	<script type="text/javascript" src="objs/sol_muret.js"></script>
	<script type="text/javascript" src="objs/sol_sable.js"></script>

	<script type="text/javascript" src="objs/pont_dessus.js"></script>
	<script type="text/javascript" src="objs/pont_pierre.js"></script>
	
	<script type="text/javascript" src="objs/tour1base.js"></script>
	<script type="text/javascript" src="objs/tour1mur.js"></script>
	<script type="text/javascript" src="objs/tour1parape.js"></script>
	<script type="text/javascript" src="objs/tour1sol.js"></script>
	<script type="text/javascript" src="objs/tour1toit.js"></script>

	<script type="text/javascript" src="objs/mur2base.js"></script>
	<script type="text/javascript" src="objs/mur2pierre.js"></script>
	<script type="text/javascript" src="objs/mur2bois.js"></script>
	<script type="text/javascript" src="objs/mur2toit.js"></script>
	
	<!-- load "modules" -->
	


	
</head>

<body>
	<br>
    <canvas id="oglcanvas" style="border: none;" width="1600" height="900"></canvas>
	<br>
</body>
	<script data-main="script/js/main" src="script/js/require.js"></script>
	
	<!-- SHADER: vertex color -->
	<!-- display the color of the  object -->
	<script id="vertex_vertex-color" type="x-shader/x-vertex">
	// vertex shader
	// ------------------------------------------------------
	// vertex color
	// ------------------------------------------------------

	// attributes inputs 
	attribute vec3 aVertexPosition;
	attribute vec3 aVertexNormal;
	attribute vec3 aVertexColor;

	// uniform matrices
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform mat3 uNMatrix;

	// uniform ambiant color
	uniform vec3 uAmbientColor;

	// output (to fragment shader)
	varying vec3 vcolor;

	void main(void) {
		// model -> view 
		vec4 mvPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
		gl_Position = uPMatrix * mvPosition;
		
		// vcolor
		vcolor = uAmbientColor+aVertexColor;
	}
</script>
	<script id="frag_vertex-color" type="x-shader/x-fragment">
	#ifdef GL_ES
		precision highp float;
	#endif

	// fragment shader
	// ------------------------------------------------------
	// vertex color
	// ------------------------------------------------------

	// varying input
	varying vec3 vcolor;

	// main
	void main(void) { gl_FragColor = vec4(vcolor, 1.0);}

</script>

	<!-- SHADER: diffus per fragment -->
	<!-- diffuse shader -->
	<script id="vertex_diffuse" type="x-shader/x-vertex">
	// vertex shader
	// ------------------------------------------------------
	// diffuse shader
	// per fragment 
	// lights nb: 1
	// ------------------------------------------------------

	// attributes inputs  (vertex arrays)
		attribute vec3 aVertexPosition;
		attribute vec3 aVertexNormal;
		attribute vec3 aVertexColor;

	// uniform matrices
		uniform mat4 uMVMatrix;
		uniform mat4 uPMatrix;
		uniform mat3 uNMatrix;

	// output (to fragment shader)
		varying vec4 vPosition;
		varying vec3 vNormal;
		varying vec3 vcolor;

	void main(void) {
		// model -> view 
		vPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
		gl_Position = uPMatrix * vPosition;
		// vNormal
		vNormal = uNMatrix * aVertexNormal;	
		// vcolor
		vcolor = aVertexColor;
	}
</script>
	<script id="frag_diffuse" type="x-shader/x-fragment">
	#ifdef GL_ES
		precision highp float;
	#endif

	// fragment shader
	// ------------------------------------------------------
	// diffuse shader
	// per fragment 
	// lights nb: 1
	// ------------------------------------------------------

	// varying input (output of the vertex shader)
		varying vec4 vPosition;
		varying vec3 vNormal;
		varying vec3 vcolor;
		
	// lights
		// ambient
		uniform vec3 uAmbientColor;

		//point light ie omni dir:  location, color
		uniform vec3 uPointLightPosition0;
		uniform vec3 uPointLightColor0;

	// local constant
		// Kd: diffuse coeff
		float Kd = 1.0 ;
	
	// main
    void main(void) {	
		// light direction
		vec3 lightDirection = normalize(uPointLightPosition0 - vPosition.xyz);
		// eye direction
		vec3 eyeDirection = normalize(-vPosition.xyz);

		// normalize normal
		vec3 normal = normalize(vNormal);
		//  diffuse term
		float diffuseLightWeight = max(dot(normal, lightDirection), 0.0);
			
		// light color
         vec3 lightColor = uAmbientColor + Kd*diffuseLightWeight*uPointLightColor0 *vcolor  ;

        gl_FragColor = vec4(lightColor,1.0);
    }
</script>

	<!-- SHADER: phong per fragment -->
	<!-- phong shader -->
	<script id="vertex_phong" type="x-shader/x-vertex">
	// vertex shader
	// ------------------------------------------------------
	// phong shader
	// per fragment 
	// lights nb: 1
	// ------------------------------------------------------

	// attributes inputs  (vertex arrays)
		attribute vec3 aVertexPosition;
		attribute vec3 aVertexNormal;
		attribute vec3 aVertexColor;

	// uniform matrices
		uniform mat4 uMVMatrix;
		uniform mat4 uPMatrix;
		uniform mat3 uNMatrix;

	// output (to fragment shader)
		varying vec4 vPosition;
		varying vec3 vNormal;
		varying vec3 vcolor;

	void main(void) {
		// model -> view 
		vPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
		gl_Position = uPMatrix * vPosition;
		// vNormal
		vNormal = uNMatrix * aVertexNormal;	
		// vcolor
		vcolor = aVertexColor;
	}
	</script>
	<script id="frag_phong" type="x-shader/x-fragment">
	#ifdef GL_ES
		precision highp float;
	#endif

	// fragment shader
	// ------------------------------------------------------
	// phong shader
	// per fragment 
	// lights nb: 1
	// ------------------------------------------------------

	// varying input (output of the vertex shader)
		varying vec4 vPosition;
		varying vec3 vNormal;
		varying vec3 vcolor;
		
	// lights
		// ambient
		uniform vec3 uAmbientColor;

		//point light ie omni dir:  location, color
		uniform vec3 uPointLightPosition0;
		uniform vec3 uPointLightColor0;

	// local constant
		// Kd: diffuse coeff
		float Kd = 0.5 ;
		float Ks = 0.5 ;
		float sh = 8.0 ;
		// specular color
		vec3 specColor = vec3(1.0,1.0,1.0);
	
	// main
    void main(void) {	
		// light direction
		vec3 lightDirection = normalize(uPointLightPosition0 - vPosition.xyz);
		
		// eye direction
		vec3 eyeDirection = normalize(-vPosition.xyz);

		// normalize normal
		vec3 normal = normalize(vNormal);
		
		// reflection direction
		vec3 reflectDirection = normalize(reflect(-lightDirection,normal));
		
		//  diffuse term
		float diffuseLightWeight = max(dot(normal, lightDirection), 0.0);
			
		// specular term
		float specularLightWeight = pow(max(dot(reflectDirection,eyeDirection),0.0),sh);
			
		// light color
         vec3 lightColor = uAmbientColor + Kd*diffuseLightWeight*uPointLightColor0 *vcolor + Ks*specularLightWeight*uPointLightColor0*specColor ;

        gl_FragColor = vec4(lightColor,1.0);
    }
	</script>	
	
	<!-- SHADER: cartoon per fragment -->
	<!-- cartoon shader -->
	<script id="vertex_cartoon" type="x-shader/x-vertex">
	// vertex shader
	// ------------------------------------------------------
	// cartoon shader
	// per fragment 
	// lights nb: 1
	// ------------------------------------------------------

	// attributes inputs  (vertex arrays)
		attribute vec3 aVertexPosition;
		attribute vec3 aVertexNormal;
		attribute vec3 aVertexColor;

	// uniform matrices
		uniform mat4 uMVMatrix;
		uniform mat4 uPMatrix;
		uniform mat3 uNMatrix;

	// output (to fragment shader)
		varying vec4 vPosition;
		varying vec3 vNormal;
		varying vec3 vcolor;

	void main(void) {
		// model -> view 
		vPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
		gl_Position = uPMatrix * vPosition;
		// vNormal
		vNormal = uNMatrix * aVertexNormal;	
		// vcolor
		vcolor = aVertexColor;
	}
	</script>
	<script id="frag_cartoon" type="x-shader/x-fragment">
	#ifdef GL_ES
		precision highp float;
	#endif

	// fragment shader
	// ------------------------------------------------------
	// cartoon shader
	// per fragment 
	// lights nb: 1
	// ------------------------------------------------------

	// varying input (output of the vertex shader)
		varying vec4 vPosition;
		varying vec3 vNormal;
		varying vec3 vcolor;
		
	// lights
		// ambient
		uniform vec3 uAmbientColor;

		//point light ie omni dir:  location, color
		uniform vec3 uPointLightPosition0;
		uniform vec3 uPointLightColor0;

	// local constant - could be uniform
		// edge color
		vec3 edgeColor = vec3(0.0,0.0,0.0);
		// shadow color
		vec3 shadowColor = vec3(0.0, 0.0, 0.5);
		// midtoneColor
		vec3 midtoneColor = vec3(0.0,0.0,1.0);
		// highlight color
		vec3 highLightColor = vec3(1.0,1.0, 1.0);
		// diffuse scpecular shininess
		float Kd = 0.5 ;
		float Ks = 0.5 ;
		float sh = 8.0 ;
		// thresholds
		float shadowMidtone = 0.0;
		float midToneHighLight = 0.75 ;
		float edgeThreshold = 0.95 ; 
	
	// main
    void main(void) {	
		// light direction
		vec3 lightDirection = normalize(uPointLightPosition0 - vPosition.xyz);
		
		// eye direction
		vec3 eyeDirection = normalize(-vPosition.xyz);

		// normalize normal
		vec3 normal = normalize(vNormal);
		
		// reflection direction
		vec3 reflectDirection = normalize(reflect(-lightDirection,normal));
		
		//  diffuse term
		float diffuse = max(dot(normal, lightDirection), 0.0);
			
		// specular term
		float specular = pow(max(dot(reflectDirection,eyeDirection),0.0),sh);
		
		// light
		float light = Kd*diffuse + Ks*specular;
		
		// edge term
		float edge = sqrt(1.0 - pow(max(dot(normal,eyeDirection),0.0),2.0));
			
		// color
         vec3 final = vec3(1.0,0.0,0.0);
         if (edge > edgeThreshold)			
         	{ final = edgeColor;}
         else if (light <= shadowMidtone) 	
         	{ final = shadowColor;}
         else if (light <= midToneHighLight)
         	{ final = midtoneColor;}
         else 								
         	{ final = highLightColor;}

        gl_FragColor = vec4(final,1.0);
    }
	</script>	

	<!-- SHADER: texture per fragment -->
	<!-- texture shader -->
	<script id="vertex_texture" type="x-shader/x-vertex">
	// vertex shader
	// ------------------------------------------------------
	// texture shader per fragment 
	// ------------------------------------------------------

	// attributes inputs  (vertex arrays)
		attribute vec3 aVertexPosition;
		attribute vec3 aVertexNormal ;
		attribute vec2 aVertexTexCoord;

	// uniform matrices
		uniform mat4 uMVMatrix;
		uniform mat4 uPMatrix;
		uniform mat3 uNMatrix;

	// output
    	varying vec2 vTextureCoord;
		varying vec4 vPosition;
		varying vec3 vNormal;

    void main(void) {
		// model -> view 
		vPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
		gl_Position = uPMatrix * vPosition;
		// vNormal
		vNormal = uNMatrix * aVertexNormal;	
		// texCoord
        vTextureCoord = aVertexTexCoord;
    }
	</script>
	<script id="frag_texture" type="x-shader/x-fragment">
	#ifdef GL_ES
		precision highp float;
	#endif
	// fragment shader
	// ------------------------------------------------------
	// texture shader per fragment 
	// ------------------------------------------------------

    varying vec2 vTextureCoord;
    uniform sampler2D uSampler0;

    void main(void) {
        gl_FragColor = texture2D(uSampler0, vec2(vTextureCoord.s, vTextureCoord.t));
    }
	</script>

	
	<!-- SHADER: textureDiff -->
	<!-- texture diffus shader -->
	<script id="vertex_texDiff" type="x-shader/x-vertex">
	// vertex shader
	// ------------------------------------------------------
	// texture shader per fragment 
	// ------------------------------------------------------
	// lights nb: 1
	// ------------------------------------------------------
	
	// attributes inputs  (vertex arrays)
		attribute vec3 aVertexPosition;
		attribute vec2 aVertexTexCoord;
		attribute vec3 aVertexNormal;

	// uniform matrices
		uniform mat4 uMVMatrix;
		uniform mat4 uPMatrix;
		uniform mat3 uNMatrix;

	// output
    	varying vec2 vTextureCoord;
		varying vec4 vPosition;
		varying vec3 vNormal;

    void main(void) {
    	// vNormal
		vNormal = uNMatrix * aVertexNormal;	
    
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        vTextureCoord = aVertexTexCoord;
    }
	</script>
	<script id="frag_texDiff" type="x-shader/x-fragment">
	#ifdef GL_ES
		precision highp float;
	#endif
	// fragment shader
	// ------------------------------------------------------
	// texture shader per fragment 
	// ------------------------------------------------------
	// lights nb: 1
	// ------------------------------------------------------
	
	// local constant
		// Kd: diffuse coeff
		float Kd = 1.0 ;	
		
	// inputs
    	varying vec2 vTextureCoord;
		varying vec4 vPosition;
		varying vec3 vNormal;
    	
    // Uniform
    	uniform sampler2D uSampler0;
    	
		// lights
		// ambient
		uniform vec3 uAmbientColor;

		//point light ie omni dir:  location, color
		uniform vec3 uPointLightPosition0;
		uniform vec3 uPointLightColor0;


    void main(void) {
    	// light direction
		vec3 lightDirection = normalize(uPointLightPosition0 - vPosition.xyz);
		// eye direction
		vec3 eyeDirection = normalize(-vPosition.xyz);

		// normalize normal
		vec3 normal = normalize(vNormal);

		//  diffuse term
		float diffuseLightWeight = max(dot(normal, lightDirection), 0.0);
		
		// texture color
		vec4 texColor  = texture2D(uSampler0, vec2(vTextureCoord.s, vTextureCoord.t));
			
		// light color
		vec3 lightColor = Kd*uAmbientColor*texColor.rgb + Kd*diffuseLightWeight*uPointLightColor0 *texColor.rgb ;



        gl_FragColor = vec4(lightColor,1.0);
    }
	</script>
	
	<!-- SHADER: texture Diffus & normal map -->
	<!-- texture diffus and normal mapshader -->
	<script id="vertex_texDiffNormalMap" type="x-shader/x-vertex">
	// vertex shader
	// ------------------------------------------------------
	// texture shader per fragment 
	// ------------------------------------------------------
	// lights nb: 1
	// ------------------------------------------------------
	
	// attributes inputs  (vertex arrays)
		attribute vec3 aVertexPosition;
		attribute vec2 aVertexTexCoord;
		attribute vec3 aVertexNormal;

	// uniform matrices
		uniform mat4 uMVMatrix;
		uniform mat4 uPMatrix;
		uniform mat3 uNMatrix;

	// output
    	varying vec2 vTextureCoord;
		varying vec4 vPosition;
		varying vec3 vNormal;

    void main(void) {
    	// vNormal
		vNormal = uNMatrix * aVertexNormal;	
    
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        vTextureCoord = aVertexTexCoord;
    }
	</script>
	<script id="frag_texDiffNormalMap" type="x-shader/x-fragment">
	#ifdef GL_ES
		precision highp float;
	#endif
	// fragment shader
	// ------------------------------------------------------
	// texture shader per fragment 
	// ------------------------------------------------------
	// lights nb: 1
	// ------------------------------------------------------
	
	// local constant
		// Kd: diffuse coeff
		float Kd = 1.0 ;	
		
	// inputs
    	varying vec2 vTextureCoord;
		varying vec4 vPosition;
		varying vec3 vNormal;
    	
    // Uniform
    	uniform sampler2D uSampler0;
    	uniform sampler2D uSampler1;
    	
		// lights
		// ambient
		uniform vec3 uAmbientColor;

		//point light ie omni dir:  location, color
		uniform vec3 uPointLightPosition0;
		uniform vec3 uPointLightColor0;


    void main(void) {
    	// light direction
		vec3 lightDirection = normalize(uPointLightPosition0 - vPosition.xyz);
		// eye direction
		vec3 eyeDirection = normalize(-vPosition.xyz);

		// normalize normal
		vec3 oldNormal = normalize(vNormal);
		// new normal in tangent space
		vec3 newNormalTS = normalize(2.0*texture2D(uSampler1, vTextureCoord).xyz -1.0) ;
		//newNormalTS.z = newNormalTS.z*1000.0;
		// newNormalTS = normalize(newNormalTS);
		// TS to View
		vec3 biTangent = cross(oldNormal,vec3(0.0,0.0,1.0));
		// test tangent
		if (dot(biTangent,biTangent) == 0.0){biTangent = cross(oldNormal,vec3(0.0,1.0,0.0));}
		vec3 tangent =  cross(biTangent,oldNormal);
		// no transpose
		vec3 u1 = tangent ;
		vec3 u2 = biTangent;
		vec3 u3 = oldNormal;		
		// TS to view matrix
		mat3 TBN = mat3(u1,u2,u3);
		// transform normal
		vec3 normal = TBN*newNormalTS ;
		//  diffuse term
		float diffuseLightWeight = max(dot(normal, lightDirection), 0.0);
		
		// texture color
		vec4 texColor  = texture2D(uSampler0, vec2(vTextureCoord.s, vTextureCoord.t));
			
		// light color
		vec3 lightColor = Kd*uAmbientColor*texColor.rgb + Kd*diffuseLightWeight*uPointLightColor0 *texColor.rgb ;



        gl_FragColor = vec4(lightColor,1.0);
    }
	</script>

	
	<!-- SHADER: wave vertex -->
	<!-- wave shader -->
	<script id="vertex_wave" type="x-shader/x-vertex">
	// vertex shader
	// ------------------------------------------------------
	// wave vertex shader
	// sum of 4 sin waves
	// ------------------------------------------------------

	// attributes inputs  (vertex arrays)
		attribute vec3 aVertexPosition;
		attribute vec3 aVertexNormal;
		attribute vec2 aVertexTexCoord;
		
	// uniform waves
	// A sin(w*u + p*t)
	// [0]: A amplitude
	// [1]: w omega
	// [2]: p phi
		uniform vec3 uA0 ;
		uniform vec3 uA1 ;
		uniform vec3 uA2 ;
		uniform vec3 uA3 ;

	// uniform
		uniform vec2 uXrange;
		
	// uniform time
		uniform float utime ;

	// uniform matrices
		uniform mat4 uMVMatrix;
		uniform mat4 uPMatrix;
		uniform mat3 uNMatrix;

	// output (to fragment shader)
		varying vec4 vPosition;
		varying vec3 vNormal;
		varying vec3 vcolor;
		varying vec2 vTextureCoord;

	void main(void) {
		float u = (aVertexPosition.x - uXrange.x)/(uXrange.y -uXrange.x)*6.28 ;
		float wupt0 = uA0.y*u+uA0.z*utime ;
		float wupt1 = uA1.y*u+uA1.z*utime ;
		float wupt2 = uA2.y*u+uA2.z*utime ;
		float wupt3 = uA3.y*u+uA3.z*utime ;
		
		// Asin
		float Asin0 = uA0.x*sin(wupt0);
		float Asin1 = uA1.x*sin(wupt1);
		float Asin2 = uA2.x*sin(wupt2);
		float Asin3 = uA3.x*sin(wupt3);
		
		float dy = Asin0 +Asin1 +Asin2 +Asin3 ;
		
		// tangent
		float tx =1.0;
		float ty0 = uA0.x*6.28*uA0.y*cos(wupt0)/(uXrange.y -uXrange.x);
		float ty1 = uA1.x*6.28*uA1.y*cos(wupt1)/(uXrange.y -uXrange.x);
		float ty2 = uA2.x*6.28*uA2.y*cos(wupt2)/(uXrange.y -uXrange.x);
		float ty3 = uA3.x*6.28*uA3.y*cos(wupt3)/(uXrange.y -uXrange.x);
		float ty = ty0 + ty1 + ty2+ ty3;
		float tz =0.0 ;
		
		// normal
		vec3 dnormal= normalize(vec3(-ty,tx,tz));
		
		// model -> view 
		vPosition = uMVMatrix * vec4(aVertexPosition+vec3(0.0,dy,0.0), 1.0);
		gl_Position = uPMatrix * vPosition;
		
		// vNormal
		vNormal = uNMatrix * (vec3(vNormal.x,0.0,vNormal.z)+dnormal);	
		
		// vTextureCoord
		vTextureCoord = aVertexTexCoord;
	}
</script>
<!-- TEST -->
	</html>